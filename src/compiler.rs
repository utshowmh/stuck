use std::{
    fs::{read_to_string, File},
    io::Write,
    process::exit,
};

use crate::{
    lexer::Lexer,
    operation::{Operation, OperationType},
};

pub struct Compiler {
    program: Vec<Operation>,
}

impl Compiler {
    pub fn new() -> Self {
        Self {
            program: Vec::new(),
        }
    }

    pub fn run(&mut self, source_path: &str) {
        let source = read_to_string(source_path).unwrap_or_else(|err| {
            eprintln!("ERROR: {:#?}", err);
            exit(1);
        });
        let mut lexer = Lexer::new(source);
        self.program.append(&mut lexer.lex());

        self.compile();
    }
}

impl Compiler {
    fn compile(&mut self) {
        let mut instruction_pointer = 0;
        let mut output = File::create("output.asm").unwrap_or_else(|err| {
            eprintln!("ERROR: {:#?}", err);
            exit(1);
        });

        write!(output, "; -- generated by STUCK --\n").unwrap();
        write!(output, "segment .text\n").unwrap();
        // DUMP FUNCTION
        write!(output, "dump:\n").unwrap();
        write!(output, "    mov     r9, -3689348814741910323\n").unwrap();
        write!(output, "    sub     rsp, 40\n").unwrap();
        write!(output, "    mov     BYTE [rsp+31], 10\n").unwrap();
        write!(output, "    lea     rcx, [rsp+30]\n").unwrap();
        write!(output, ".L2:\n").unwrap();
        write!(output, "    mov     rax, rdi\n").unwrap();
        write!(output, "    lea     r8, [rsp+32]\n").unwrap();
        write!(output, "    mul     r9\n").unwrap();
        write!(output, "    mov     rax, rdi\n").unwrap();
        write!(output, "    sub     r8, rcx\n").unwrap();
        write!(output, "    shr     rdx, 3\n").unwrap();
        write!(output, "    lea     rsi, [rdx+rdx*4]\n").unwrap();
        write!(output, "    add     rsi, rsi\n").unwrap();
        write!(output, "    sub     rax, rsi\n").unwrap();
        write!(output, "    add     eax, 48\n").unwrap();
        write!(output, "    mov     BYTE [rcx], al\n").unwrap();
        write!(output, "    mov     rax, rdi\n").unwrap();
        write!(output, "    mov     rdi, rdx\n").unwrap();
        write!(output, "    mov     rdx, rcx\n").unwrap();
        write!(output, "    sub     rcx, 1\n").unwrap();
        write!(output, "    cmp     rax, 9\n").unwrap();
        write!(output, "    ja      .L2\n").unwrap();
        write!(output, "    lea     rax, [rsp+32]\n").unwrap();
        write!(output, "    mov     edi, 1\n").unwrap();
        write!(output, "    sub     rdx, rax\n").unwrap();
        write!(output, "    xor     eax, eax\n").unwrap();
        write!(output, "    lea     rsi, [rsp+32+rdx]\n").unwrap();
        write!(output, "    mov     rdx, r8\n").unwrap();
        write!(output, "    mov     rax, 1\n").unwrap();
        write!(output, "    syscall\n").unwrap();
        write!(output, "    add     rsp, 40\n").unwrap();
        write!(output, "    ret\n").unwrap();
        // END DUMP
        write!(output, "global _start\n").unwrap();
        write!(output, "\n").unwrap();
        write!(output, "_start:\n").unwrap();

        while instruction_pointer < self.program.len() {
            let operation = &self.program[instruction_pointer];

            match operation.op_type {
                OperationType::Push => {
                    if let Some(operand) = operation.operand {
                        write!(output, "    ; -- push -- \n").unwrap();
                        write!(output, "    push {} \n", operand).unwrap();
                    }

                    instruction_pointer += 1;
                }

                OperationType::Dup => {
                    write!(output, "    ; -- dup -- \n").unwrap();
                    write!(output, "    pop rax \n").unwrap();
                    write!(output, "    push rax \n").unwrap();
                    write!(output, "    push rax \n").unwrap();

                    instruction_pointer += 1;
                }

                OperationType::Plus => {
                    write!(output, "    ; -- plus -- \n").unwrap();
                    write!(output, "    pop rax \n").unwrap();
                    write!(output, "    pop rbx \n").unwrap();
                    write!(output, "    add rax, rbx \n").unwrap();
                    write!(output, "    push rax \n").unwrap();

                    instruction_pointer += 1;
                }

                OperationType::Minus => {
                    write!(output, "    ; -- minus -- \n").unwrap();
                    write!(output, "    pop rax \n").unwrap();
                    write!(output, "    pop rbx \n").unwrap();
                    write!(output, "    sub rbx, rax \n").unwrap();
                    write!(output, "    push rbx \n").unwrap();

                    instruction_pointer += 1;
                }

                OperationType::Equal => {
                    write!(output, "    ; -- equal -- \n").unwrap();
                    write!(output, "    mov rcx, 0 \n").unwrap();
                    write!(output, "    mov rdx, 1 \n").unwrap();
                    write!(output, "    pop rax \n").unwrap();
                    write!(output, "    pop rbx \n").unwrap();
                    write!(output, "    cmp rax, rbx \n").unwrap();
                    write!(output, "    cmove rcx, rdx \n").unwrap();
                    write!(output, "    push rcx \n").unwrap();

                    instruction_pointer += 1;
                }

                OperationType::Greater => {
                    write!(output, "    ; -- greater -- \n").unwrap();
                    write!(output, "    mov rcx, 0 \n").unwrap();
                    write!(output, "    mov rdx, 1 \n").unwrap();
                    write!(output, "    pop rbx \n").unwrap();
                    write!(output, "    pop rax \n").unwrap();
                    write!(output, "    cmp rax, rbx \n").unwrap();
                    write!(output, "    cmovg rcx, rdx \n").unwrap();
                    write!(output, "    push rcx \n").unwrap();

                    instruction_pointer += 1;
                }

                OperationType::If => {
                    instruction_pointer += 1;
                }

                OperationType::Then => {
                    if let Some(end_block) = operation.operand {
                        write!(output, "    ; -- then -- \n").unwrap();
                        write!(output, "    pop rax \n").unwrap();
                        write!(output, "    test rax, rax \n").unwrap();
                        write!(output, "    jz addr_{} \n", end_block).unwrap();
                    } else {
                        self.invalid_reference(&format!(
                            "`then` does not have reference to the `end` block in line {}",
                            operation.line
                        ));
                    }

                    instruction_pointer += 1;
                }

                OperationType::Else => {
                    if let Some(end_block) = operation.operand {
                        write!(output, "    ; -- else -- \n").unwrap();
                        write!(output, "    jmp addr_{} \n", end_block).unwrap();
                        write!(output, "addr_{}: \n", instruction_pointer + 1).unwrap();
                    } else {
                        self.invalid_reference(&format!(
                            "`else` does not have reference to it's `end` block in line {}",
                            operation.line
                        ));
                    }

                    instruction_pointer += 1;
                }

                OperationType::While => {
                    write!(output, "    ; -- while -- \n").unwrap();
                    write!(output, "addr_{}: \n", instruction_pointer).unwrap();

                    instruction_pointer += 1;
                }

                OperationType::Do => {
                    if let Some(end_block) = operation.operand {
                        write!(output, "    ; -- do -- \n").unwrap();
                        write!(output, "    pop rax \n").unwrap();
                        write!(output, "    test rax, rax \n").unwrap();
                        write!(output, "    jz addr_{} \n", end_block).unwrap();
                    } else {
                        self.invalid_reference(&format!(
                            "`then` does not have reference to the `end` block in line {}",
                            operation.line
                        ));
                    }

                    instruction_pointer += 1;
                }

                OperationType::End => {
                    write!(output, "    ; -- end -- \n").unwrap();
                    write!(output, "addr_{}: \n", instruction_pointer + 1).unwrap();
                    if let Some(jump_address) = operation.operand {
                        write!(output, "    jmp addr_{} \n", jump_address).unwrap();
                    }

                    instruction_pointer += 1;
                }

                OperationType::Dump => {
                    write!(output, "    ; -- dump -- \n").unwrap();
                    write!(output, "    pop rdi \n").unwrap();
                    write!(output, "    call dump \n").unwrap();

                    instruction_pointer += 1;
                }
            }
        }

        write!(output, "    mov rax, 60 \n").unwrap();
        write!(output, "    mov rdi, 0 \n").unwrap();
        write!(output, "    syscall \n").unwrap();
    }

    fn invalid_reference(&self, message: &str) {
        self.error("Invalid Reference", message);
    }

    fn error(&self, e_type: &str, message: &str) {
        eprintln!("{}: {}", e_type, message);
        exit(1);
    }
}
